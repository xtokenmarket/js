import { BigNumber } from '@ethersproject/bignumber';
import { Abi, ADDRESSES, BANCOR_CONTRACT_REGISTRY, BNT, BUY, ETH, } from '@xtoken/abis';
import { Contract } from 'ethers';
import { formatBytes32String, formatEther, parseEther } from 'ethers/lib/utils';
import { BNT_ETH_PATH, DEC_18 } from '../../constants';
import { getBancorPoolContract, getSigner, getTokenSymbol } from '../utils';
import { getXBntPrices } from '../xbnt';
import { getXBntContracts } from '../xbnt/helper';
import { getBalances } from './helper';
import { getEthUsdcPrice } from './uniswap';
export const getBancorNetworkAddress = async (provider) => {
    const network = await provider.getNetwork();
    const { chainId } = network;
    const ContractRegistry = new Contract(ADDRESSES[BANCOR_CONTRACT_REGISTRY][chainId], Abi.BancorContractRegistry, getSigner(provider));
    const bancorNetworkName = formatBytes32String('BancorNetwork');
    return ContractRegistry.addressOf(bancorNetworkName);
};
export const getBntEthPrice = async (provider) => {
    const bancorNetworkAddress = await getBancorNetworkAddress(provider);
    const BancorNetworkContract = new Contract(bancorNetworkAddress, Abi.BancorNetwork, getSigner(provider));
    const rate = await BancorNetworkContract.rateByPath(BNT_ETH_PATH, parseEther('1'));
    return formatEther(rate);
};
export const getBancorEstimatedQuantity = async (tokenIn, symbol, amount, tradeType, provider) => {
    const network = await provider.getNetwork();
    const { chainId } = network;
    const inputAmount = parseEther(amount);
    const token = getTokenSymbol(symbol);
    // Bancor Network Contract
    const bancorNetworkAddress = await getBancorNetworkAddress(provider);
    const BancorNetworkContract = new Contract(bancorNetworkAddress, Abi.BancorNetwork, getSigner(provider));
    // Addresses
    const bntAddress = ADDRESSES[token][chainId];
    const xbntAddress = ADDRESSES[symbol][chainId];
    let tokenInAddress;
    let tokenOutAddress;
    if (tradeType === BUY) {
        tokenInAddress = tokenIn === ETH ? ADDRESSES[ETH] : bntAddress;
        tokenOutAddress = xbntAddress;
    }
    else {
        tokenInAddress = xbntAddress;
        tokenOutAddress = tokenIn === ETH ? ADDRESSES[ETH] : bntAddress;
    }
    const path = await BancorNetworkContract.conversionPath(tokenInAddress, tokenOutAddress);
    const rate = await BancorNetworkContract.rateByPath(path, inputAmount);
    return formatEther(rate);
};
export const getBancorPortfolioItem = async (symbol, address, provider) => {
    const { network, xbntContract } = await getXBntContracts(symbol, provider);
    const { chainId } = network;
    const asset = `${symbol} - ${BNT.toUpperCase()}`;
    // Pool address which has `xBNTa` and `BNT` balances
    const bancorPoolAddress = '0xA35Cf3bDF58EF1cE6a9657659Ebe4cD8b491F2cE';
    // Contracts
    const bancorPoolContract = getBancorPoolContract(symbol, provider, chainId);
    let userBalance = BigNumber.from('0');
    try {
        userBalance = await bancorPoolContract.balanceOf(address);
    }
    catch (e) {
        console.error('Error while fetching user balance:', e);
    }
    const [ethUsdcPrice, bntEthPrice] = await Promise.all([
        getEthUsdcPrice(provider),
        getBntEthPrice(provider),
    ]);
    const underlyingPrice = parseEther(bntEthPrice)
        .mul(parseEther(ethUsdcPrice))
        .div(DEC_18);
    const { priceUsd } = await getXBntPrices(xbntContract);
    const bancorPoolBalances = await getBalances(symbol, bancorPoolAddress, priceUsd, provider, chainId, underlyingPrice, false);
    const xbntBntPoolSupply = await bancorPoolContract.totalSupply();
    const poolPrice = parseEther(bancorPoolBalances.totalVal)
        .mul(DEC_18)
        .div(xbntBntPoolSupply);
    const value = poolPrice.mul(userBalance).div(DEC_18);
    return {
        asset,
        balances: bancorPoolBalances,
        poolPrice: formatEther(poolPrice),
        quantity: formatEther(userBalance),
        tokenPrice: priceUsd,
        value: formatEther(value),
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFuY29yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2Jsb2NrY2hhaW4vZXhjaGFuZ2VzL2JhbmNvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sMEJBQTBCLENBQUE7QUFFcEQsT0FBTyxFQUNMLEdBQUcsRUFDSCxTQUFTLEVBQ1Qsd0JBQXdCLEVBQ3hCLEdBQUcsRUFDSCxHQUFHLEVBQ0gsR0FBRyxHQUVKLE1BQU0sY0FBYyxDQUFBO0FBQ3JCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxRQUFRLENBQUE7QUFDakMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQTtBQUUvRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFBO0FBR3RELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxTQUFTLEVBQUUsY0FBYyxFQUFFLE1BQU0sVUFBVSxDQUFBO0FBQzNFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxTQUFTLENBQUE7QUFDdkMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sZ0JBQWdCLENBQUE7QUFFakQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLFVBQVUsQ0FBQTtBQUN0QyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sV0FBVyxDQUFBO0FBRTNDLE1BQU0sQ0FBQyxNQUFNLHVCQUF1QixHQUFHLEtBQUssRUFDMUMsUUFBc0IsRUFDTCxFQUFFO0lBQ25CLE1BQU0sT0FBTyxHQUFHLE1BQU0sUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFBO0lBQzNDLE1BQU0sRUFBRSxPQUFPLEVBQUUsR0FBRyxPQUFPLENBQUE7SUFFM0IsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLFFBQVEsQ0FDbkMsU0FBUyxDQUFDLHdCQUF3QixDQUFDLENBQUMsT0FBTyxDQUFDLEVBQzVDLEdBQUcsQ0FB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